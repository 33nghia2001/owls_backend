"""
Custom JWT Authentication Middleware for Django Channels WebSockets.
Securely authenticate WebSocket connections using HttpOnly cookies instead of URL params.
"""
from channels.db import database_sync_to_async
from channels.middleware import BaseMiddleware
from django.contrib.auth.models import AnonymousUser
from django.contrib.auth import get_user_model
from rest_framework_simplejwt.tokens import AccessToken
from rest_framework_simplejwt.exceptions import TokenError, InvalidToken
from urllib.parse import parse_qs

User = get_user_model()


class JWTAuthMiddleware(BaseMiddleware):
    """
    Custom middleware to authenticate WebSocket connections via JWT.
    
    Priority order:
    1. HttpOnly Cookie (Most secure - recommended for production)
    2. One-time ticket from query params (Fallback)
    
    NEVER accepts long-lived JWT tokens from URL to prevent token leakage.
    """
    
    async def __call__(self, scope, receive, send):
        # Try to authenticate from cookies first (secure method)
        scope['user'] = await self.get_user_from_cookie(scope)
        
        # If no cookie, try one-time ticket (if implemented)
        if scope['user'].is_anonymous:
            scope['user'] = await self.get_user_from_ticket(scope)
        
        return await super().__call__(scope, receive, send)
    
    @database_sync_to_async
    def get_user_from_cookie(self, scope):
        """
        Authenticate user from HttpOnly cookie.
        
        Frontend should include credentials when creating WebSocket:
            const ws = new WebSocket('ws://localhost:8000/ws/notifications/');
            // Cookies are automatically sent with WebSocket handshake
        """
        try:
            # Get cookies from headers
            cookies = {}
            for header_name, header_value in scope.get('headers', []):
                if header_name == b'cookie':
                    cookie_str = header_value.decode()
                    for cookie in cookie_str.split('; '):
                        if '=' in cookie:
                            key, value = cookie.split('=', 1)
                            cookies[key] = value
            
            # Get access token from cookie
            access_token_str = cookies.get('access_token')
            if not access_token_str:
                return AnonymousUser()
            
            # Validate JWT token
            access_token = AccessToken(access_token_str)
            user_id = access_token['user_id']
            
            # Get user from database
            user = User.objects.select_related().get(id=user_id)
            return user
            
        except (TokenError, InvalidToken, User.DoesNotExist, KeyError):
            return AnonymousUser()
    
    @database_sync_to_async
    def get_user_from_ticket(self, scope):
        """
        Authenticate using one-time ticket (if ticket system is implemented).
        
        Ticket should be:
        - Short-lived (10-30 seconds)
        - Single-use only
        - Generated by a separate API endpoint
        
        Usage:
        1. Frontend calls POST /api/ws/ticket/ to get one-time ticket
        2. Connect WebSocket: ws://domain/ws/notifications/?ticket=abc123
        3. Server validates and invalidates ticket immediately
        """
        try:
            # Get query string
            query_string = scope.get('query_string', b'').decode()
            query_params = parse_qs(query_string)
            
            ticket = query_params.get('ticket', [None])[0]
            if not ticket:
                return AnonymousUser()
            
            # IMPLEMENTATION COMPLETE: Atomic ticket validation using Redis Lua script
            # This prevents race conditions where multiple connections try to use the same ticket
            from django.core.cache import cache
            
            ticket_key = f'ws_ticket:{ticket}'
            
            # Use Lua script for truly atomic GET + DELETE operation
            # This is superior to separate get() and delete() calls
            redis_client = cache.client.get_client()
            
            # Lua script ensures atomicity - either get value AND delete, or get nothing
            # This prevents the race condition window between get() and delete()
            lua_script = """
            local value = redis.call('GET', KEYS[1])
            if value then
                redis.call('DEL', KEYS[1])
                return value
            else
                return nil
            end
            """
            
            try:
                # Execute Lua script atomically on Redis server
                user_id = redis_client.eval(lua_script, 1, ticket_key)
                
                if user_id:
                    # Decode bytes to string if necessary
                    if isinstance(user_id, bytes):
                        user_id = int(user_id.decode())
                    else:
                        user_id = int(user_id)
                    
                    # Get user from database
                    try:
                        user = User.objects.get(id=user_id)
                        return user
                    except User.DoesNotExist:
                        # User was deleted between ticket creation and usage
                        return AnonymousUser()
                
                # Ticket doesn't exist or already used
                return AnonymousUser()
                
            except Exception as e:
                # Fallback: If Lua script fails, try standard approach
                # This handles cases where Redis doesn't support eval or client issues
                user_id = cache.get(ticket_key)
                if user_id:
                    deleted = cache.delete(ticket_key)
                    if deleted:
                        try:
                            user = User.objects.get(id=user_id)
                            return user
                        except User.DoesNotExist:
                            return AnonymousUser()
                
                return AnonymousUser()
            
            return AnonymousUser()
            
        except (User.DoesNotExist, Exception):
            return AnonymousUser()


def JWTAuthMiddlewareStack(inner):
    """
    Helper function to wrap WebSocket routes with JWT authentication.
    
    Usage in asgi.py:
        from apps.notifications.middleware import JWTAuthMiddlewareStack
        
        application = ProtocolTypeRouter({
            "websocket": JWTAuthMiddlewareStack(
                URLRouter(websocket_urlpatterns)
            ),
        })
    """
    return JWTAuthMiddleware(inner)
