"""
Custom JWT Authentication Middleware for Django Channels WebSockets.
Securely authenticate WebSocket connections using HttpOnly cookies instead of URL params.
"""
from channels.db import database_sync_to_async
from channels.middleware import BaseMiddleware
from django.contrib.auth.models import AnonymousUser
from django.contrib.auth import get_user_model
from rest_framework_simplejwt.tokens import AccessToken
from rest_framework_simplejwt.exceptions import TokenError, InvalidToken
from urllib.parse import parse_qs

User = get_user_model()


class JWTAuthMiddleware(BaseMiddleware):
    """
    Custom middleware to authenticate WebSocket connections via JWT.
    
    Priority order:
    1. HttpOnly Cookie (Most secure - recommended for production)
    2. One-time ticket from query params (Fallback)
    
    NEVER accepts long-lived JWT tokens from URL to prevent token leakage.
    """
    
    async def __call__(self, scope, receive, send):
        # Try to authenticate from cookies first (secure method)
        scope['user'] = await self.get_user_from_cookie(scope)
        
        # If no cookie, try one-time ticket (if implemented)
        if scope['user'].is_anonymous:
            scope['user'] = await self.get_user_from_ticket(scope)
        
        return await super().__call__(scope, receive, send)
    
    @database_sync_to_async
    def get_user_from_cookie(self, scope):
        """
        Authenticate user from HttpOnly cookie.
        
        Frontend should include credentials when creating WebSocket:
            const ws = new WebSocket('ws://localhost:8000/ws/notifications/');
            // Cookies are automatically sent with WebSocket handshake
        """
        try:
            # Get cookies from headers
            cookies = {}
            for header_name, header_value in scope.get('headers', []):
                if header_name == b'cookie':
                    cookie_str = header_value.decode()
                    for cookie in cookie_str.split('; '):
                        if '=' in cookie:
                            key, value = cookie.split('=', 1)
                            cookies[key] = value
            
            # Get access token from cookie
            access_token_str = cookies.get('access_token')
            if not access_token_str:
                return AnonymousUser()
            
            # Validate JWT token
            access_token = AccessToken(access_token_str)
            user_id = access_token['user_id']
            
            # Get user from database
            user = User.objects.select_related().get(id=user_id)
            return user
            
        except (TokenError, InvalidToken, User.DoesNotExist, KeyError):
            return AnonymousUser()
    
    @database_sync_to_async
    def get_user_from_ticket(self, scope):
        """
        Authenticate using one-time ticket (if ticket system is implemented).
        
        Ticket should be:
        - Short-lived (10-30 seconds)
        - Single-use only
        - Generated by a separate API endpoint
        
        Usage:
        1. Frontend calls POST /api/ws/ticket/ to get one-time ticket
        2. Connect WebSocket: ws://domain/ws/notifications/?ticket=abc123
        3. Server validates and invalidates ticket immediately
        """
        try:
            # Get query string
            query_string = scope.get('query_string', b'').decode()
            query_params = parse_qs(query_string)
            
            ticket = query_params.get('ticket', [None])[0]
            if not ticket:
                return AnonymousUser()
            
            # TODO: Implement ticket validation
            # - Check if ticket exists in Redis
            # - Check if not expired (< 30 seconds old)
            # - Delete ticket after first use (single-use)
            # - Return associated user
            
            # SECURITY FIX (Gemini Audit): Atomic get-and-delete to prevent ticket replay
            # Multiple concurrent connections could reuse the same ticket if get/delete aren't atomic
            from django.core.cache import cache
            
            # Use cache.get() then cache.delete() with existence check
            # For Redis 6.2+, this could be replaced with GETDEL command via Lua script
            ticket_key = f'ws_ticket:{ticket}'
            user_id = cache.get(ticket_key)
            
            if user_id:
                # Attempt to delete - if it returns False, another request already used it
                deleted = cache.delete(ticket_key)
                if not deleted:
                    # Ticket was already consumed by another connection
                    return AnonymousUser()
                
                try:
                    user = User.objects.get(id=user_id)
                    return user
                except User.DoesNotExist:
                    return AnonymousUser()
            
            return AnonymousUser()
            
        except (User.DoesNotExist, Exception):
            return AnonymousUser()


def JWTAuthMiddlewareStack(inner):
    """
    Helper function to wrap WebSocket routes with JWT authentication.
    
    Usage in asgi.py:
        from apps.notifications.middleware import JWTAuthMiddlewareStack
        
        application = ProtocolTypeRouter({
            "websocket": JWTAuthMiddlewareStack(
                URLRouter(websocket_urlpatterns)
            ),
        })
    """
    return JWTAuthMiddleware(inner)
